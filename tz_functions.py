# -*- coding: utf-8 -*-
"""TZ_functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GcwBsBAMRkBOAlhJEG_5IivfNzLa_qmk
"""

# di() = teljes szélességű, nem sortört táblázat új függvénnyel

from IPython.display import display, HTML

def di(pr):
    """
    Kiírja az adott pandas DataFrame-et HTML táblázatként.

    Parameters:
    - pr: pandas DataFrame
    """
    display(HTML(pr.to_html()))

# Példa használat:
# di(df)  # df-nek helyettesítsd be a valós DataFrame-edet


# 240502 li() = struktúrált listázó függvény, bővítve alapértelmezettel, teljes szélességű, nem sortört táblázat, sorszám inputtal.************ ADATDOKI ***************
# módosított kód, amely a bemenet bekérését és kiértékelését kihagyja, ha van beállított alapértelmezett érték.
# az alapértelmezett sor beállítható az"enter" változóval, pl. "enter=4" vagy "del enter"

import pandas as pd
from IPython.display import display, HTML

enter = input("Legyen alapértelmezett sorok száma? 0 = ne legyen, azaz listázáskor rákérdez. Vagy szám = ennyi sort listáz rákérdezés nélkül. ")

if enter == '0':
    del enter
elif not enter.isdigit():
    print("Érvénytelen bemenet!")
    enter = None
else:
    enter = int(enter)

def list_unique_values(df):
    try:
        default_rows = enter  # Az alapértelmezett sorok száma
        display(HTML(df.head(default_rows).to_html()))
    except NameError:
        try:
            bemenet = input("Kérem, adja meg a bemenetet (0 = továbblép azaz nem listáz, ENTER = alapértelmezett számú, vagy hiányában minden sort listáz): ")
            if bemenet == '0':
                return
            elif bemenet == '':
                display(HTML(df.to_html()))  # Teljes DataFrame listázása
            elif bemenet.isdigit():
                display(HTML(df.head(int(bemenet)).to_html()))
            else:
                print("Érvénytelen bemenet!")
        except NameError:
            print("Hiba: Hiányzó 'enter' változó.")

# Példa használat:
# li(dataframe) dataframe-nek helyettesítsd be a valós DataFrame-edet

# 240507 *********TZ*********** kilistázza az egyedi értékeket *************ADATDOKI***************
# mind a szöveges, mind a numerikus oszlopokban megszámolja az egyedi értékeket DI kiírással,
# 5 paraméterrel: df_name, beállítható megjelenítési számmal (list_values=5),
# csak 1 oszlop lehetőséggel is (columns=['name', 'start']),
# csak szöveges vagy numerikus oszlopok (dtype="numeric");(dtype="object");(dtype="all")
# Függvény meghívása ötödik paraméterrel, hogy csak keresett értékkel rendelkező sorok jelenjenek meg
# list_unique_values(df_EFC_CZ_merged, list_values=3, columns=['chng', 'chng_1'], dtype="object", search_value="valami")
# minden egyes oszlop mellett ki lesz írva az oszlop típusa is.

import numpy as np

#def list_unique_values(dataframe, list_values=10, columns=None, dtype="all", search_value=None):
if columns is None:
    columns = dataframe.columns.tolist()

for column in columns:
    print('PARAMÉTEREZÉS: luv(dataframe, list_values=10, columns=["column1", "column2", ...], dtype="all/object/int64/float64/datetime64", search_value="valami")  = list_unique_values(dataframe)')
    if dtype == "numeric" and not np.issubdtype(dataframe[column].dtype, np.number):
        continue
    elif dtype == "object" and not np.issubdtype(dataframe[column].dtype, object):
        continue

    column_type = dataframe[column].dtype
    if search_value:
        values = dataframe[dataframe[column] == search_value][column].value_counts()
    else:
        values = dataframe[column].value_counts()

    # Átmeneti DataFrame létrehozása sorszámozással
    temp_df = pd.DataFrame(values).rename(columns={column: 'Egyedi db'})
    temp_df.index.name = 'Értékek'
    temp_df.reset_index(inplace=True)
    print(f"Egyedi értékek a(z) \033[1m'{column}'\033[0m '\033[4moszlopban\033[0m', (melynek típusa: {column_type}) (összesen: {len(values)} db) (sorok száma: {len(dataframe)})")
    di(temp_df.head(list_values))
    #di(temp_df.tail(list_values))
    print(f"Sorok száma: {len(dataframe)}")
    print()

# Függvény meghívása alapértelmezett értékkel
# list_unique_values(df_EFC_CZ_merged)

# Függvény meghívása második és harmadik paraméter megadásával
# list_unique_values(df_EFC_CZ_merged, list_values=5, columns=['name', 'start'])  # Például az utolsó 5 érték megjelenítése a "name" és "start" oszlopokban

# Függvény meghívása negyedik paraméterrel, hogy csak szöveges vagy numerikus oszlopok jelenjenek meg
# list_unique_values(df_EFC_CZ_merged, list_values=5, columns=['chng', 'chng_1'], dtype="numeric")

# Függvény meghívása keresendő értékkel
# list_unique_values(df_EFC_CZ_merged, search_value="valami")

# Függvény meghívása ötödik paraméterrel, hogy csak keresett értékkel rendelkező sorok jelenjenek meg
# list_unique_values(df_EFC_CZ_merged, list_values=15, columns=['chng', 'chng_1', 'chng_2',], dtype="object", search_value="vběhl")
# list_unique_values(df_EFC_CZ_merged, list_values=15, search_value="vběhl")
# list_unique_values(df_EFC_CZ_merged, list_values=15)

def luv(dataframe, list_values=10, columns=None, dtype="all", search_value=None):
    list_unique_values(dataframe, list_values, columns, dtype, search_value)



"""
240505
Ebben a kódban a plot_histograms függvényt definiáljuk, amely paraméterként várja a DataFrame nevét (dataframe_name).
A függvény megpróbálja betölteni a megadott DataFrame-et, és ha nem találja, hibát kezel.
Az iteráció és hisztogram kirajzolás része ugyanaz maradt. Most példa használatként megadhatod a DataFrame nevét a plot_histograms függvényben.
Ebben a kódban az `x_bin_width` és `y_bin_width` változókat 1%-os értékekre állítottam,
majd ezeket használtam a `bins` paraméterek megfelelő számának kiszámításához mind az X, mind az Y tengelyen.
`bin_width` értéke az adott oszlop MAX-MIN értékeinek megadott %-ától függ
"""

import pandas as pd
import matplotlib.pyplot as plt

def plot_histograms(dataframe_name):
    try:
        # Betöltjük a DataFrame-et a megadott név alapján
        df = globals()[dataframe_name]

        print("ilyen oszlopaink vannak: (csak a numerikusokról hisztogram)")
        df.info()

        # Iteráció az oszlopokon és hisztogramok kirajzolása
        for column in df.columns:
            # Csak numerikus oszlopokat veszünk figyelembe (elhagyjuk a nem numerikusakat)
            if pd.api.types.is_numeric_dtype(df[column]):
                # Számold ki a MAX és MIN értékek különbségének megadott %-át
                bin_width = 0.01 * (df[column].max() - df[column].min())
                # Készíts egyedi ábrát minden oszlophoz
                plt.figure(figsize=(8, 6))

                # Készíts hisztogramot a számolt bin-szélességgel
                plt.hist(df[column], bins=int((df[column].max() - df[column].min()) / bin_width),
                         color='blue', edgecolor='black', alpha=0.5)

                # Ábra címe és tengelyfeliratai
                plt.title(f'Histogram of {column} in {dataframe_name}')
                plt.xlabel(column)
                plt.ylabel('Frequency')

                # Minden egyes oszlop ábrát külön mutasd be
                plt.show()

    except KeyError:
        print(f"Error: DataFrame with name '{dataframe_name}' not found.")

# Példa használat:
#plot_histograms("df")
#print(df)


import numpy as np  # NumPy importálása
from scipy import stats  # Scipy importálása a statisztikai műveletekhez

def numeric_column_summary_statistics(df):
    # Az összes oszlop fejlécének kiválasztása
    all_columns = df.columns

    # Csak a számot tartalmazó oszlopok kiválasztása
    numeric_columns = df.select_dtypes(include='number').columns

    # Statisztikák kiszámolása minden oszlopra
    statistics = pd.DataFrame(index=['Min', 'Max', 'Átlag', 'Medián', 'Modusz', 'Variabilitás', 'Alsó Kvantil', 'Felső Kvantil',
                                     'Korreláció', 'Kovariancia', 'Százalékos Változás', 'Konfidencia-intervallumok',
                                     'Lineáris Regresszió Együtthatók'], columns=all_columns)

    for column in all_columns:
        if column in numeric_columns:
            statistics.at['Min', column] = df[column].min()
            statistics.at['Max', column] = df[column].max()
            statistics.at['Átlag', column] = df[column].mean()
            statistics.at['Medián', column] = df[column].median()
            statistics.at['Modusz', column] = df[column].mode().iloc[0]  # Modusz számítása
            statistics.at['Variabilitás', column] = df[column].std()  # Szórás
            statistics.at['Alsó Kvantil', column] = df[column].quantile(0.25)  # Alsó kvantil
            statistics.at['Felső Kvantil', column] = df[column].quantile(0.75)  # Felső kvantil
            # Korreláció és kovariancia kiszámítása a többi oszloppal
            for other_column in numeric_columns:
                if other_column != column:
                    statistics.at['Korreláció', column] = df[column].corr(df[other_column])
                    statistics.at['Kovariancia', column] = df[column].cov(df[other_column])
            # Százalékos változás számítása
            first_value = df[column].iloc[0]
            last_value = df[column].iloc[-1]
            statistics.at['Százalékos Változás', column] = ((last_value - first_value) / first_value) * 100
            # Konfidencia-intervallumok
            confidence_interval = stats.norm.interval(0.95, loc=df[column].mean(), scale=df[column].std())
            statistics.at['Konfidencia-intervallumok', column] = confidence_interval
            # Lineáris regresszió együtthatók
            # Ez csak egy példa, itt valószínűleg több munka és elemzés kellene
            slope, intercept, r_value, p_value, std_err = stats.linregress(df[column], df['start'])
            statistics.at['Lineáris Regresszió Együtthatók', column] = (slope, intercept, r_value, p_value, std_err)
        else:
            # Nem szám típusú oszlopoknak NaN értékeket adunk
            statistics.at['Min', column] = np.nan
            statistics.at['Max', column] = np.nan
            statistics.at['Átlag', column] = np.nan
            statistics.at['Medián', column] = np.nan
            statistics.at['Modusz', column] = np.nan
            statistics.at['Variabilitás', column] = np.nan
            statistics.at['Alsó Kvantil', column] = np.nan
            statistics.at['Felső Kvantil', column] = np.nan
            statistics.at['Korreláció', column] = np.nan
            statistics.at['Kovariancia', column] = np.nan
            statistics.at['Százalékos Változás', column] = np.nan
            statistics.at['Konfidencia-intervallumok', column] = np.nan
            statistics.at['Lineáris Regresszió Együtthatók', column] = np.nan

    # Statisztikák kiíratása
    print("Összefoglaló statisztikák minden oszlopra:")
    display(statistics)

# numeric_column_summary_statistics(df)
