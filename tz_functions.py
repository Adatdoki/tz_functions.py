# -*- coding: utf-8 -*-
"""TZ_functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GcwBsBAMRkBOAlhJEG_5IivfNzLa_qmk
"""

print(" ############### ADATDOKI f√ºggv√©nyei   ############### ")
print(" ############### TZ_functions.py       ############### ")
print(" ############### version = 2025.12.10. ############### ")

###### 2025.12.10. 11:36 #######################################################################################################################################

def qdi(df, **kwargs):
    """
    M√©g egyszer≈±bb query - kulcs=√©rt√©k p√°rokkal.
    
    Haszn√°lat:
    qlist2(df, leltsz="info_0818", beszar=13050)
    """
    
    if not kwargs:
        print("‚ùå Nincsenek felt√©telek megadva!")
        return df
    
    conditions = []
    for column, value in kwargs.items():
        # D√°tum/string kezel√©s
        if isinstance(value, str):
            if ' ' in value or '-' in value or ':' in value:  # D√°tum/sz√∂veg
                conditions.append(f'{column} == "{value}"')
            else:
                conditions.append(f'{column} == "{value}"')
        else:  # Sz√°m
            conditions.append(f'{column} == {value}')
    
    query_string = ' and '.join(conditions)
    print(f"üîç Query: {query_string}")
    
    try:
        result = df.query(query_string)
        print(f"‚úÖ Tal√°latok: {len(result)} sor")
        return result
    except Exception as e:
        print(f"‚ùå Hiba: {e}")
        display(pd.DataFrame())
        return pd.DataFrame()

################################################################################################################################################################

# di() = teljes sz√©less√©g≈±, nem sort√∂rt t√°bl√°zat √∫j f√ºggv√©nnyel

from IPython.display import display, HTML

def di(pr):
    """
    Ki√≠rja az adott pandas DataFrame-et HTML t√°bl√°zatk√©nt, kattinthat√≥ linkekkel.

    Parameters:
    - pr: pandas DataFrame
    """
    # HTML t√°bl√°zat gener√°l√°sa kattinthat√≥ linkekkel
    display(HTML(pr.to_html(escape=False, render_links=True)))

# P√©lda haszn√°lat:
# di(df)  # df-nek helyettes√≠tsd be a val√≥s DataFrame-edet


################################################################################################################################################################

# 240510 li() = strukt√∫r√°lt list√°z√≥ f√ºggv√©ny, b≈ëv√≠tve alap√©rtelmezettel, teljes sz√©less√©g≈±, nem sort√∂rt t√°bl√°zat, sorsz√°m inputtal.************ ADATDOKI ***************
# m√≥dos√≠tott k√≥d, amely a bemenet bek√©r√©s√©t √©s ki√©rt√©kel√©s√©t kihagyja, ha van be√°ll√≠tott alap√©rtelmezett √©rt√©k.
# az alap√©rtelmezett sor be√°ll√≠that√≥ az"enter" v√°ltoz√≥val, pl. "enter=4" vagy "del enter"
# els≈ë param√©tere k√∂telez≈ë a "dataframe", m√°sodik opcion√°lis (az adott futtat√°sban ki√≠rand√≥ sorok sz√°ma, ha -1 akkor az √∂sszes sor)
# Ki√≠rja az adott pandas DataFrame-et HTML t√°bl√°zatk√©nt, kattinthat√≥ linkekkel.

import pandas as pd
from IPython.display import display, HTML

try:
    del enter
    enter  # Ellen≈ërizz√ºk, hogy az enter v√°ltoz√≥ l√©tezik-e
except NameError:
    # Az enter v√°ltoz√≥ l√©trehoz√°sa √©s alap√©rtelmezett √©rt√©k√©nek be√°ll√≠t√°sa
    # print("A li() f√ºggv√©ny list√°z√°sn√°l, legyen alap√©rtelmezett a sorok sz√°ma?")
    enter_input = '10'
    #enter_input = input(' 0 = ne legyen, azaz list√°z√°skor r√°k√©rdez. Vagy sz√°m = ennyi sort list√°z r√°k√©rdez√©s n√©lk√ºl. ("enter" v√°ltoz√≥)')
    if enter_input == '0':
        enter = None
    elif enter_input.isdigit():
        enter = int(enter_input)
    else:
        print("√ârv√©nytelen bemenet!")
        enter = None

def li(df, rows=None):
    
	# Az rows param√©ter haszn√°lata, ha meg van adva
    if rows is not None:
        if rows == -1:
            display(HTML(df.to_html(escape=False, render_links=True, index=True)))
            print("haszn√°lat: li(df)  # Haszn√°lja az 'enter' v√°ltoz√≥ √©rt√©k√©t ha l√©tezik √©s nagyobb mint 0, k√ºl√∂nben az √∂sszes sort megjelen√≠ti vagy li(df, -1)")
        else:
            try:
                # Pr√≥b√°ljuk meg √©rtelmezni, hogy rows sz√°m-e
                display_rows = int(rows)
                display(HTML(df.head(display_rows).to_html(escape=False, render_links=True, index=True)))
                print("haszn√°lat: li(df)  # Haszn√°lja az 'enter' v√°ltoz√≥ √©rt√©k√©t ha l√©tezik √©s nagyobb mint 0, k√ºl√∂nben az √∂sszes sort megjelen√≠ti vagy li(df, -1)")
            except ValueError:
                print("A 'rows' param√©ternek '*' vagy egy pozit√≠v eg√©sz sz√°mnak kell lennie.")
                print("haszn√°lat: li(df)  # Haszn√°lja az 'enter' v√°ltoz√≥ √©rt√©k√©t ha l√©tezik √©s nagyobb mint 0, k√ºl√∂nben az √∂sszes sort megjelen√≠ti vagy li(df, -1)")
    elif enter and enter > 0:  # Ellen≈ërizz√ºk, hogy az enter √©rt√©ke nagyobb-e mint 0
        display(HTML(df.head(enter).to_html(escape=False, render_links=True, index=True)))
        print("haszn√°lat: li(df)  # Haszn√°lja az 'enter' v√°ltoz√≥ √©rt√©k√©t ha l√©tezik √©s nagyobb mint 0, k√ºl√∂nben az √∂sszes sort megjelen√≠ti vagy li(df, -1)")
    else:
        display(HTML(pr.to_html(escape=False, render_links=True, index=True)))  # Alap√©rtelmezett vagy √∂sszes sor list√°z√°sa
        print("haszn√°lat: li(df)  # Haszn√°lja az 'enter' v√°ltoz√≥ √©rt√©k√©t ha l√©tezik √©s nagyobb mint 0, k√ºl√∂nben az √∂sszes sort megjelen√≠ti vagy li(df, -1)")

# P√©lda haszn√°lat:
# li(dataframe) dataframe-nek helyettes√≠tsd be a val√≥s DataFrame-edet
# df = pd.DataFrame({'A': range(1, 6), 'B': range(6, 11)})
# li(df)  # Haszn√°lja az "enter" √©rt√©k√©t ha l√©tezik √©s nagyobb mint 0, k√ºl√∂nben az √∂sszes sort megjelen√≠ti
# li(df, 2)  # Csak 2 sort jelen√≠t meg a DataFrame-b≈ël

# 240507 *********TZ*********** kilist√°zza az egyedi √©rt√©keket *************ADATDOKI***************
# mind a sz√∂veges, mind a numerikus oszlopokban megsz√°molja az egyedi √©rt√©keket DI ki√≠r√°ssal,
# 5 param√©terrel: df_name, be√°ll√≠that√≥ megjelen√≠t√©si sz√°mmal (list_values=5),
# csak 1 oszlop lehet≈ës√©ggel is (columns=['name', 'start']),
# csak sz√∂veges vagy numerikus oszlopok (dtype="numeric");(dtype="object");(dtype="all")
# F√ºggv√©ny megh√≠v√°sa √∂t√∂dik param√©terrel, hogy csak keresett √©rt√©kkel rendelkez≈ë sorok jelenjenek meg
# list_unique_values(df_EFC_CZ_merged, list_values=3, columns=['chng', 'chng_1'], dtype="object", search_value="valami")
# minden egyes oszlop mellett ki lesz √≠rva az oszlop t√≠pusa is.

################################################################################################################################################################

import numpy as np

def list_unique_values(dataframe, list_values=10, columns=None, dtype="all", search_value=None):
    if columns is None:
        columns = sorted(dataframe.columns.tolist())  # Az oszlopok rendez√©se n√∂vekv≈ë sorrendben

    for column in columns:
        print('PARAM√âTEREZ√âS: luv(dataframe, list_values=10, columns=["column1", "column2", ...], dtype="all/object/int64/float64/datetime64", search_value="valami")  = list_unique_values(dataframe)')
        if dtype == "numeric" and not np.issubdtype(dataframe[column].dtype, np.number):
            continue
        elif dtype == "object" and not np.issubdtype(dataframe[column].dtype, object):
            continue

        column_type = dataframe[column].dtype
        if search_value:
            values = dataframe[dataframe[column] == search_value][column].value_counts()
        else:
            values = dataframe[column].value_counts()

        # √ârt√©kek rendez√©se n√∂vekv≈ë sorrendben
        values_sorted = values.sort_index()

        # √Åtmeneti DataFrame l√©trehoz√°sa sorsz√°moz√°ssal
        temp_df = pd.DataFrame(values_sorted).rename(columns={column: 'Egyedi db'})
        temp_df.index.name = '√ârt√©kek'
        temp_df.reset_index(inplace=True)
        print(f"Egyedi √©rt√©kek a(z) \033[1m'{column}'\033[0m '\033[4moszlopban\033[0m', (melynek t√≠pusa: {column_type}) (√∂sszesen: {len(values)} db) (sorok sz√°ma: {len(dataframe)})")
        di(temp_df.head(list_values))
        #di(temp_df.tail(list_values))
        print(f"Sorok sz√°ma: {len(dataframe)}")
        print()

# F√ºggv√©ny megh√≠v√°sa alap√©rtelmezett √©rt√©kkel
# list_unique_values(df_EFC_CZ_merged)

# F√ºggv√©ny megh√≠v√°sa m√°sodik √©s harmadik param√©ter megad√°s√°val
# list_unique_values(df_EFC_CZ_merged, list_values=5, columns=['name', 'start'])  # P√©ld√°ul az utols√≥ 5 √©rt√©k megjelen√≠t√©se a "name" √©s "start" oszlopokban

# F√ºggv√©ny megh√≠v√°sa negyedik param√©terrel, hogy csak sz√∂veges vagy numerikus oszlopok jelenjenek meg
# list_unique_values(df_EFC_CZ_merged, list_values=5, columns=['chng', 'chng_1'], dtype="numeric")

# F√ºggv√©ny megh√≠v√°sa keresend≈ë √©rt√©kkel
# list_unique_values(df_EFC_CZ_merged, search_value="valami")

# F√ºggv√©ny megh√≠v√°sa √∂t√∂dik param√©terrel, hogy csak keresett √©rt√©kkel rendelkez≈ë sorok jelenjenek meg
# list_unique_values(df_EFC_CZ_merged, list_values=15, columns=['chng', 'chng_1', 'chng_2',], dtype="object", search_value="vbƒõhl")
# list_unique_values(df_EFC_CZ_merged, list_values=15, search_value="vbƒõhl")
# list_unique_values(df_EFC_CZ_merged, list_values=15)

def luv(dataframe, list_values=10, columns=None, dtype="all", search_value=None):
    list_unique_values(dataframe, list_values, columns, dtype, search_value)

################################################################################################################################################################

# plot_histograms 240821
"""
Ebben a k√≥dban a plot_histograms f√ºggv√©nyt defini√°ljuk, amely param√©terk√©nt v√°rja a DataFrame nev√©t (dataframe_name).
A f√ºggv√©ny megpr√≥b√°lja bet√∂lteni a megadott DataFrame-et, √©s ha nem tal√°lja, hib√°t kezel.
Az iter√°ci√≥ √©s hisztogram kirajzol√°s r√©sze ugyanaz maradt. Most p√©lda haszn√°latk√©nt megadhatod a DataFrame nev√©t a plot_histograms f√ºggv√©nyben.
Ebben a k√≥dban az `x_bin_width` √©s `y_bin_width` v√°ltoz√≥kat 1%-os √©rt√©kekre √°ll√≠tottam,
majd ezeket haszn√°ltam a `bins` param√©terek megfelel≈ë sz√°m√°nak kisz√°m√≠t√°s√°hoz mind az X, mind az Y tengelyen.
`bin_width` √©rt√©ke az adott oszlop MAX-MIN √©rt√©keinek megadott %-√°t√≥l f√ºgg
"""

import matplotlib.pyplot as plt
import pandas as pd

def plot_histograms(df):
    try:
        print("Ilyen oszlopaink vannak: (csak a numerikusokr√≥l hisztogram)")
        df.info()

        # Iter√°ci√≥ az oszlopokon √©s hisztogramok kirajzol√°sa
        for column in df.columns:
            if pd.api.types.is_numeric_dtype(df[column]):
                # Sz≈±rj√ºk ki a NaN √©rt√©keket
                col_data = df[column].dropna()

                # Ellen≈ërizz√ºk, hogy van-e legal√°bb k√©t k√ºl√∂nb√∂z≈ë √©rt√©k
                if col_data.nunique() > 1:
                    bin_width = 0.01 * (col_data.max() - col_data.min())
                    bins = int((col_data.max() - col_data.min()) / bin_width)

                    plt.figure(figsize=(8, 6))
                    plt.hist(col_data, bins=bins, color='blue', edgecolor='black', alpha=0.5)
                    plt.title(f'Histogram of {column}')
                    plt.xlabel(column)
                    plt.ylabel('Frequency')
                    plt.show()

                    # Felt√©telezve, hogy a Pearson_egy_oszlop_vizsgalata f√ºggv√©ny l√©tezik
                    print(Pearson_egy_oszlop_vizsgalata(df, column))
                    print("=============================================================================================================================================================")

                else:
                    print(f"Az '{column}' oszlopban nincs elegend≈ë v√°ltozatoss√°g a hisztogram k√©sz√≠t√©s√©hez.")

    except KeyError:
        print("Hiba: A DataFrame nem tal√°lhat√≥.")

# P√©lda haszn√°lat:
# plot_histograms(df)


################################################################################################################################################################

import numpy as np  # NumPy import√°l√°sa
from scipy import stats  # Scipy import√°l√°sa a statisztikai m≈±veletekhez

def numeric_column_summary_statistics(df):
    # Az √∂sszes oszlop fejl√©c√©nek kiv√°laszt√°sa
    all_columns = df.columns

    # Csak a sz√°mot tartalmaz√≥ oszlopok kiv√°laszt√°sa
    numeric_columns = df.select_dtypes(include='number').columns

    # Statisztik√°k kisz√°mol√°sa minden oszlopra
    statistics = pd.DataFrame(index=['Min', 'Max', '√Åtlag', 'Medi√°n', 'Modusz', 'Variabilit√°s', 'Als√≥ Kvantil', 'Fels≈ë Kvantil',
                                     'Korrel√°ci√≥', 'Kovariancia', 'Sz√°zal√©kos V√°ltoz√°s', 'Konfidencia-intervallumok',
                                     'Line√°ris Regresszi√≥ Egy√ºtthat√≥k'], columns=all_columns)

    for column in all_columns:
        if column in numeric_columns:
            statistics.at['Min', column] = df[column].min()
            statistics.at['Max', column] = df[column].max()
            statistics.at['√Åtlag', column] = df[column].mean()
            statistics.at['Medi√°n', column] = df[column].median()
            statistics.at['Modusz', column] = df[column].mode().iloc[0]  # Modusz sz√°m√≠t√°sa
            statistics.at['Variabilit√°s', column] = df[column].std()  # Sz√≥r√°s
            statistics.at['Als√≥ Kvantil', column] = df[column].quantile(0.25)  # Als√≥ kvantil
            statistics.at['Fels≈ë Kvantil', column] = df[column].quantile(0.75)  # Fels≈ë kvantil
            # Korrel√°ci√≥ √©s kovariancia kisz√°m√≠t√°sa a t√∂bbi oszloppal
            for other_column in numeric_columns:
                if other_column != column:
                    statistics.at['Korrel√°ci√≥', column] = df[column].corr(df[other_column])
                    statistics.at['Kovariancia', column] = df[column].cov(df[other_column])
            # Sz√°zal√©kos v√°ltoz√°s sz√°m√≠t√°sa
            first_value = df[column].iloc[0]
            last_value = df[column].iloc[-1]
            statistics.at['Sz√°zal√©kos V√°ltoz√°s', column] = ((last_value - first_value) / first_value) * 100
            # Konfidencia-intervallumok
            confidence_interval = stats.norm.interval(0.95, loc=df[column].mean(), scale=df[column].std())
            statistics.at['Konfidencia-intervallumok', column] = confidence_interval
            # Line√°ris regresszi√≥ egy√ºtthat√≥k
            # Ez csak egy p√©lda, itt val√≥sz√≠n≈±leg t√∂bb munka √©s elemz√©s kellene
            slope, intercept, r_value, p_value, std_err = stats.linregress(df[column], df['start'])
            statistics.at['Line√°ris Regresszi√≥ Egy√ºtthat√≥k', column] = (slope, intercept, r_value, p_value, std_err)
        else:
            # Nem sz√°m t√≠pus√∫ oszlopoknak NaN √©rt√©keket adunk
            statistics.at['Min', column] = np.nan
            statistics.at['Max', column] = np.nan
            statistics.at['√Åtlag', column] = np.nan
            statistics.at['Medi√°n', column] = np.nan
            statistics.at['Modusz', column] = np.nan
            statistics.at['Variabilit√°s', column] = np.nan
            statistics.at['Als√≥ Kvantil', column] = np.nan
            statistics.at['Fels≈ë Kvantil', column] = np.nan
            statistics.at['Korrel√°ci√≥', column] = np.nan
            statistics.at['Kovariancia', column] = np.nan
            statistics.at['Sz√°zal√©kos V√°ltoz√°s', column] = np.nan
            statistics.at['Konfidencia-intervallumok', column] = np.nan
            statistics.at['Line√°ris Regresszi√≥ Egy√ºtthat√≥k', column] = np.nan

    # Statisztik√°k ki√≠rat√°sa
    print("√ñsszefoglal√≥ statisztik√°k minden oszlopra:")
    display(statistics)

# numeric_column_summary_statistics(df)

################################################################################################################################################################

######### 2024.10.27 22:58:00 ################################## ADATDOKI ######
# A DataFrame oszlopainak tulajdons√°gait √∂sszegz≈ë funkci√≥. Egy dataframe adatainak t√°bl√°zatos statisztik√°ja.
# https://chatgpt.com/g/g-1NfAVvTfO-hu-jup-python-mester/c/670f693a-a67c-8005-9ffd-140995861135
#########1#########2#########3#########4#########5#########6#########7#########8
"""
Kifejez√©s            | Le√≠r√°s
---------------------|-----------------------------------------------------
Dtype                | Az oszlop adatt√≠pusa.
count                | Az oszlopban l√©v≈ë nem NaN √©rt√©kek sz√°ma.
unique               | Az oszlopban l√©v≈ë egyedi √©rt√©kek sz√°ma.
top                  | Az oszlopban leggyakrabban el≈ëfordul√≥ √©rt√©k.
freq                 | Az oszlopban leggyakrabban el≈ëfordul√≥ √©rt√©k gyakoris√°ga.
mean                 | Az oszlopban l√©v≈ë √©rt√©kek √°tlaga.
std                  | Az oszlopban l√©v≈ë √©rt√©kek sz√≥r√°sa.
min                  | Az oszlop legkisebb √©rt√©ke.
25%                  | Az oszlop als√≥ kvartilise (25%-os percentilis).
50%                  | Az oszlop medi√°nja (50%-os percentilis).
75%                  | Az oszlop fels≈ë kvartilise (75%-os percentilis).
max                  | Az oszlop legnagyobb √©rt√©ke.
first                | Az oszlopban az els≈ë nem NaN √©rt√©k.
last                 | Az oszlopban az utols√≥ nem NaN √©rt√©k.
NaN_count            | Az oszlopban l√©v≈ë NaN √©rt√©kek sz√°ma.
unique_top           | Az oszlopban l√©v≈ë egyedi √©rt√©kek k√∂z√ºl a leggyakoribb.
unique_top_count     | Az oszlopban l√©v≈ë egyedi √©rt√©kek k√∂z√ºl a leggyakoribb √©rt√©k el≈ëfordul√°sainak sz√°ma.

"""

import inspect

# Dekor√°tor f√ºggv√©ny l√©trehoz√°sa
def add_df_name(func):
    def wrapper(df):
        # Az aktu√°lis h√≠v√°si keretet megvizsg√°ljuk, hogy lek√©rj√ºk a v√°ltoz√≥ nev√©t
        frame = inspect.currentframe().f_back
        df_name = None
        
        # V√©gigmegy√ºnk a v√°ltoz√≥kon, √©s megkeress√ºk azt, amelyik a DataFrame-re mutat
        for name, val in frame.f_locals.items():
            if val is df:
                df_name = name
                break
        
        # Ha megtal√°ltuk a nevet, √°tadjuk azt a dinfo-nak
        return func(df, df_name)
    
    return wrapper

# A dinfo f√ºggv√©ny
@add_df_name  # Ezzel a dekor√°torral "d√≠sz√≠tj√ºk" a dinfo-t
def dinfo(df, df_name):
    # Ellen≈ërizz√ºk, hogy a DataFrame nem √ºres
    if df.empty:
        print(f"A {df_name} DataFrame √ºres.")
        return

    # Ki√≠rjuk az oszlopok statisztikai jellemz≈ëit √©s a sorok sz√°m√°t
    print(f"\n({df_name}) DataFrame oszlopainak statisztik√°i: {len(df)} sorb√≥l √°ll.")
    
    # K√ºl√∂n list√°k a numerikus √©s nem numerikus oszlopok sz√°m√°ra
    numeric_stats = []
    non_numeric_stats = []

    # Minden oszlopot k√ºl√∂n-k√ºl√∂n ellen≈ërz√ºnk
    for col in df.columns:
        try:
            # Pr√≥b√°lunk numerikus statisztik√°t kisz√°m√≠tani az oszlopra
            col_stats = df[[col]].describe().T  # Ha siker√ºl, numerikus
            numeric_stats.append(col_stats)
        except (ValueError, TypeError):
            # Ha nem numerikus, akkor csak alap statisztik√°kat sz√°molunk
            col_stats = df[[col]].describe(include='all').T
            non_numeric_stats.append(col_stats)

    # Egyes√≠tj√ºk a numerikus √©s nem numerikus statisztik√°kat
    if numeric_stats:
        numeric_stats_df = pd.concat(numeric_stats, axis=0)
    else:
        numeric_stats_df = pd.DataFrame()

    if non_numeric_stats:
        non_numeric_stats_df = pd.concat(non_numeric_stats, axis=0)
    else:
        non_numeric_stats_df = pd.DataFrame()

    # √ñsszevonjuk a statisztikai adatokat egy DataFrame-be
    statistics_df = pd.concat([numeric_stats_df, non_numeric_stats_df], axis=0)

    # Ellen≈ërizz√ºk, hogy minden sz√ºks√©ges oszlop l√©tezik-e, ha nem, akkor hozz√°adjuk None √©rt√©kkel
    required_columns = ['count', 'unique', 'top', 'freq', 'mean', 'std', 'min', '25%', '50%', '75%', 'max']
    for col in required_columns:
        if col not in statistics_df.columns:
            statistics_df[col] = None

    # Hozz√°adjuk az els≈ë √©s utols√≥ elemet, ha vannak adatok
    statistics_df['first'] = df.apply(lambda x: x.dropna().iloc[0] if not x.dropna().empty else None)
    statistics_df['last'] = df.apply(lambda x: x.dropna().iloc[-1] if not x.dropna().empty else None)

    # NaN √©rt√©kek sz√°mol√°sa
    statistics_df['NaN_count'] = df.isnull().sum()

    # Leggyakoribb egyedi √©rt√©k
    unique_top_values = df.apply(lambda x: x.value_counts().index[0] if not x.value_counts().empty else None)
    statistics_df['unique_top'] = unique_top_values

    # Leggyakoribb egyedi √©rt√©k darabsz√°ma
    unique_top_counts = df.apply(lambda x: x.value_counts().max() if not x.value_counts().empty else None)
    statistics_df['unique_top_count'] = unique_top_counts

    # Oszlopok t√≠pus√°nak hozz√°ad√°sa
    statistics_df.insert(1, 'Dtype', df.dtypes)

    # Oszlopok t√≠pus√°nak hozz√°ad√°sa √©s √∫j sorrend
    statistics_df.insert(0, '#', range(1, len(statistics_df) + 1))
    statistics_df = statistics_df[['#', 'Dtype', 'count', 'unique', 'top', 'freq', 'mean', 'std', 'min', '25%', '50%', '75%', 'max', 'first', 'last', 'NaN_count', 'unique_top', 'unique_top_count']]

    # Itt a statisztik√°k megjelen√≠t√©se (felt√©telezem, hogy van egy di() f√ºggv√©nyed erre)
    di(statistics_df)

    return

# haszn√°lat:
# dinfo(df)

################################################################################################################################################################

# 240507 *********TZ*********** datainfo *************ADATDOKI***************
# kilist√°zza a dataframe tulajdons√°gait
databases = ["default_dataframe"]  # Alap√©rtelmezett DataFrame
#functions = [".info()", ".describe()", ".head()", "", ".dtypes"]
functions = [".info()", ".describe()", "",]

def datainfo(dataframe=None):
    if dataframe is None:
        dataframe = databases[0]

    for f in functions:
        command = dataframe + f
        print("\n==>", command)
        output = eval(command)
        print(output)

# Haszn√°lat: datainfo() vagy datainfo("custom_dataframe")

###################################################################################################################################################

import numpy as np  # NumPy import√°l√°sa
from scipy import stats  # Scipy import√°l√°sa a statisztikai m≈±veletekhez

def numeric_column_summary_statistics(df):
    # Az √∂sszes oszlop fejl√©c√©nek kiv√°laszt√°sa
    all_columns = df.columns

    # Csak a sz√°mot tartalmaz√≥ oszlopok kiv√°laszt√°sa
    numeric_columns = df.select_dtypes(include='number').columns

    # Statisztik√°k kisz√°mol√°sa minden oszlopra
    statistics = pd.DataFrame(index=['Min', 'Max', '√Åtlag', 'Medi√°n', 'Modusz', 'Variabilit√°s', 'Als√≥ Kvantil', 'Fels≈ë Kvantil',
                                     'Korrel√°ci√≥', 'Kovariancia', 'Sz√°zal√©kos V√°ltoz√°s', 'Konfidencia-intervallumok',
                                     'Line√°ris Regresszi√≥ Egy√ºtthat√≥k'], columns=all_columns)

    for column in all_columns:
        if column in numeric_columns:
            statistics.at['Min', column] = df[column].min()
            statistics.at['Max', column] = df[column].max()
            statistics.at['√Åtlag', column] = df[column].mean()
            statistics.at['Medi√°n', column] = df[column].median()
            statistics.at['Modusz', column] = df[column].mode().iloc[0]  # Modusz sz√°m√≠t√°sa
            statistics.at['Variabilit√°s', column] = df[column].std()  # Sz√≥r√°s
            statistics.at['Als√≥ Kvantil', column] = df[column].quantile(0.25)  # Als√≥ kvantil
            statistics.at['Fels≈ë Kvantil', column] = df[column].quantile(0.75)  # Fels≈ë kvantil
            # Korrel√°ci√≥ √©s kovariancia kisz√°m√≠t√°sa a t√∂bbi oszloppal
            for other_column in numeric_columns:
                if other_column != column:
                    statistics.at['Korrel√°ci√≥', column] = df[column].corr(df[other_column])
                    statistics.at['Kovariancia', column] = df[column].cov(df[other_column])
            # Sz√°zal√©kos v√°ltoz√°s sz√°m√≠t√°sa
            first_value = df[column].iloc[0]
            last_value = df[column].iloc[-1]
            statistics.at['Sz√°zal√©kos V√°ltoz√°s', column] = ((last_value - first_value) / first_value) * 100
            # Konfidencia-intervallumok
            confidence_interval = stats.norm.interval(0.95, loc=df[column].mean(), scale=df[column].std())
            statistics.at['Konfidencia-intervallumok', column] = confidence_interval
            # Line√°ris regresszi√≥ egy√ºtthat√≥k
            # Ez csak egy p√©lda, itt val√≥sz√≠n≈±leg t√∂bb munka √©s elemz√©s kellene
            slope, intercept, r_value, p_value, std_err = stats.linregress(df[column], df['start'])
            statistics.at['Line√°ris Regresszi√≥ Egy√ºtthat√≥k', column] = (slope, intercept, r_value, p_value, std_err)
        else:
            # Nem sz√°m t√≠pus√∫ oszlopoknak NaN √©rt√©keket adunk
            statistics.at['Min', column] = np.nan
            statistics.at['Max', column] = np.nan
            statistics.at['√Åtlag', column] = np.nan
            statistics.at['Medi√°n', column] = np.nan
            statistics.at['Modusz', column] = np.nan
            statistics.at['Variabilit√°s', column] = np.nan
            statistics.at['Als√≥ Kvantil', column] = np.nan
            statistics.at['Fels≈ë Kvantil', column] = np.nan
            statistics.at['Korrel√°ci√≥', column] = np.nan
            statistics.at['Kovariancia', column] = np.nan
            statistics.at['Sz√°zal√©kos V√°ltoz√°s', column] = np.nan
            statistics.at['Konfidencia-intervallumok', column] = np.nan
            statistics.at['Line√°ris Regresszi√≥ Egy√ºtthat√≥k', column] = np.nan

    # Statisztik√°k ki√≠rat√°sa
    print("√ñsszefoglal√≥ statisztik√°k minden oszlopra:")
    display(statistics)

# numeric_column_summary_statistics(df)

##############################################################################################################################################

# 240510 √ârt√©kek list√°z√°sa v√°laszthat√≥ oszlopokban
import shutil

def values(dataframe, columns, max_values_per_line=20, sorted=False):
    for column in columns:
        # Sz√°mk√©nt √©rtelmezhet≈ë √©rt√©kek keres√©se
        numeric_values = pd.to_numeric(dataframe[column], errors='coerce')

        # Norm√°lalakos sz√°mokat keres√ºnk, amelyeket nem tudunk √©rtelmezni
        non_normal_numeric_values = dataframe[column][~numeric_values.notnull()].unique()

        # Statisztik√°k numerikus √©rt√©kekr≈ël
        if len(numeric_values.dropna()) > 0:
            print(f"Statistics for column '{column}' (numerical values):")
            print(numeric_values.dropna().describe())
            print()

        # Egyedi √©rt√©kek numerikus √©rt√©kekr≈ël
        unique_numeric_values = numeric_values.dropna().unique()
        if len(unique_numeric_values) > 0:
            if sorted:
                unique_numeric_values.sort()
            print(f"Unique values in column '{column}' (numerical values):")
            terminal_width = shutil.get_terminal_size().columns
            values_per_line = min(max_values_per_line, terminal_width // 7)  # 7 is the average width of a float number
            for i in range(0, len(unique_numeric_values), values_per_line):
                print("\t".join([f"{value:.2f}" for value in unique_numeric_values[i:i+values_per_line]]))
            print()

        # Nem numerikus √©rt√©kek list√°z√°sa
        if len(non_normal_numeric_values) > 0:
            print(f"Non-numeric values in column '{column}':")
            if sorted:
                print(", ".join(map(str, non_normal_numeric_values)))
            else:
                print(", ".join(sorted(map(str, non_normal_numeric_values))))
            print()
			
# F√ºggv√©ny megh√≠v√°sa az adott DataFrame √©s oszlop nev√©vel
# values(df_EFC_CZ_merged, ('sorsz', 'Division', 'when', 'who', 'with_who', 'total_time', 'W/L/T', 'Hurdles', 'name', 'start', '1_dog', 'name_1', 'chng', '2_dog', 'name_2', 'chng_1', '3_dog', 'name_3', 'chng_2', '4_dog', 'event_place', 'when_date', 'when_time', 'track'), max_values_per_line=25, sorted=True)
# values(df_EFC_CZ_merged, ('start', 'chng', 'chng_1', 'chng_2'), sorted=True)

##############################################################################################################################################

#240331 mind a sz√∂veges, mind a numerikus oszlopokban megsz√°molja az egyedi √©rt√©keket DI ki√≠r√°ssal, be√°ll√≠that√≥ megjelen√≠t√©si sz√°mmal, csak 1 oszlop lehet≈ës√©ggel is
def list_unique_values_240331(dataframe, list_values=10, columns=None):
    if columns is None:
        columns = dataframe.columns.tolist()

    for column in columns:
        values = dataframe[column].value_counts()
        # √Åtmeneti DataFrame l√©trehoz√°sa sorsz√°moz√°ssal
        temp_df = pd.DataFrame(values).rename(columns={column: 'Egyedi db'})
        temp_df.index.name = '√ârt√©kek'
        temp_df.reset_index(inplace=True)
        print(f"Egyedi √©rt√©kek a(z) '{column}' oszlopban (√∂sszesen: {len(values)} db):")
        di(temp_df.head(list_values))
        di(temp_df.tail(list_values))
        print()

# F√ºggv√©ny megh√≠v√°sa alap√©rtelmezett √©rt√©kkel
#list_unique_values(df_EFC_CZ_merged)

# F√ºggv√©ny megh√≠v√°sa m√°sodik √©s harmadik param√©ter megad√°s√°val
# list_unique_values_240331(df_EFC_CZ_merged, list_values=5, columns=['name', 'start'])  # P√©ld√°ul az utols√≥ 5 √©rt√©k megjelen√≠t√©se a "name" √©s "start" oszlopokban
# list_unique_values_240331(df_EFC_CZ_merged, list_values=25, columns=['start', 'chng', 'chng_1', 'chng_2'])

##############################################################################################################################################
# 240821 A DataFrame √∂sszes oszlop√°n v√©gigiter√°l, √©s minden oszlopra megvizsg√°lja, hogy megfelel-e a Pearson-f√©le korrel√°ci√≥s egy√ºtthat√≥ felt√©teleinek.
import numpy as np
import pandas as pd
import scipy.stats as stats

def Pearson_egy_oszlop_vizsgalata(df, oszlop, folytonos_kuszob=20, min_kulonbseg_kuszob=0.01):
    """
    Egy adott oszlop vizsg√°lata a Pearson-f√©le korrel√°ci√≥s egy√ºtthat√≥ felt√©teleinek szempontj√°b√≥l.
    
    Param√©terek:
    df : pd.DataFrame
        Az adatokat tartalmaz√≥ DataFrame.
    oszlop : str
        A vizsg√°land√≥ oszlop neve.
    folytonos_kuszob : int
        Az egyedi √©rt√©kek sz√°m√°nak k√ºsz√∂be, amely felett folytonosnak tekintj√ºk a v√°ltoz√≥t.
    min_kulonbseg_kuszob : float
        Az √©rt√©kek k√∂z√∂tti minim√°lis k√ºl√∂nbs√©g k√ºsz√∂be, amely alatt a v√°ltoz√≥t folytonosnak tekintj√ºk.
    
    Visszat√©r√©si √©rt√©k:
    dict : Az ellen≈ërz√©si eredm√©nyek sz√≥t√°ra.
    """
    eredmenyek = {}
    
    try:
        # 1. Numerikus v√°ltoz√≥k ellen≈ërz√©se
        if pd.api.types.is_numeric_dtype(df[oszlop]):
            eredmenyek['numerikus_valtozok'] = True
        else:
            eredmenyek['numerikus_valtozok'] = False

        # 2. Norm√°l eloszl√°s ellen≈ërz√©se (Shapiro-Wilk teszt)
        _, p_x = stats.shapiro(df[oszlop])

        # A Shapiro-Wilk teszt p-√©rt√©ke alapj√°n d√∂nts√ºnk: ha p > 0.05, akkor norm√°lis eloszl√°s√∫
        eredmenyek['normal_eloszlas_x'] = p_x > 0.05

        # 3. Folytonos v√°ltoz√≥k ellen≈ërz√©se

        # 3.1 Egyedi √©rt√©kek sz√°m√°nak vizsg√°lata
        egyedi_ertekek_x = df[oszlop].nunique()
        eredmenyek['folytonos_valtozo_x_ertekszam'] = egyedi_ertekek_x > folytonos_kuszob

        # 3.2 √ârt√©kek k√∂z√∂tti k√ºl√∂nbs√©gek vizsg√°lata
        kulonbsegek_x = np.diff(np.sort(df[oszlop].unique()))
        min_kulonbseg_x = np.min(kulonbsegek_x)
        eredmenyek['folytonos_valtozo_x_kulonbseg'] = min_kulonbseg_x < min_kulonbseg_kuszob

        # A k√©t krit√©rium kombin√°l√°s√°val meg√°llap√≠tjuk, hogy folytonos-e a v√°ltoz√≥
        eredmenyek['folytonos_x'] = (eredmenyek['folytonos_valtozo_x_ertekszam'] and eredmenyek['folytonos_valtozo_x_kulonbseg'])

    except Exception as e:
        # Hibakezel√©s: Ha valami hiba t√∂rt√©nik, r√∂gz√≠tj√ºk az √ºzenetet
        eredmenyek['hiba'] = str(e)

    return eredmenyek

def Pearson_osszes_oszlop_vizsgalata(df):
    """
    A DataFrame √∂sszes oszlop√°n v√©gigiter√°l, √©s minden oszlopra megvizsg√°lja, hogy megfelel-e a Pearson-f√©le korrel√°ci√≥s egy√ºtthat√≥ felt√©teleinek.
    
    Param√©ter:
    df : pd.DataFrame
        Az elemzend≈ë adatkeret.
    """
    for oszlop in df.columns:
        print(f'\nOszlop n√©v: {oszlop}')
        print('-----------------------')
        eredmeny = Pearson_egy_oszlop_vizsgalata(df, oszlop)
        for kulcs, ertek in eredmeny.items():
            print(f'{kulcs}: {ertek}')

# P√©ldafelhaszn√°l√°s:
# df = pd.read_csv("adatok.csv")
# Pearson_osszes_oszlop_vizsgalata(df)


#############################################################################################################################################

# 240821 ColStat, Column statisztika
import numpy as np
import pandas as pd
import scipy.stats as stats

def egy_oszlop_vizsgalata(df, oszlop, folytonos_kuszob=20, min_kulonbseg_kuszob=0.01):
    """
    Egy adott oszlop vizsg√°lata a Pearson-f√©le korrel√°ci√≥s egy√ºtthat√≥ felt√©teleinek szempontj√°b√≥l.
    
    Param√©terek:
    df : pd.DataFrame
        Az adatokat tartalmaz√≥ DataFrame.
    oszlop : str
        A vizsg√°land√≥ oszlop neve.
    folytonos_kuszob : int
        Az egyedi √©rt√©kek sz√°m√°nak k√ºsz√∂be, amely felett folytonosnak tekintj√ºk a v√°ltoz√≥t.
    min_kulonbseg_kuszob : float
        Az √©rt√©kek k√∂z√∂tti minim√°lis k√ºl√∂nbs√©g k√ºsz√∂be, amely alatt a v√°ltoz√≥t folytonosnak tekintj√ºk.
    
    Visszat√©r√©si √©rt√©k:
    dict : Az ellen≈ërz√©si eredm√©nyek sz√≥t√°ra.
    """
    eredmenyek = {
        'numerikus_valtozok': False,
        'normal_eloszlas_x': False,
        'folytonos_valtozo_x_ertekszam': False,
        'folytonos_valtozo_x_kulonbseg': False,
        'folytonos_x': False,
        'hiba': np.nan  # Eredetileg nincs hiba
    }
    
    try:
        # 1. Numerikus v√°ltoz√≥k ellen≈ërz√©se
        if pd.api.types.is_numeric_dtype(df[oszlop]):
            eredmenyek['numerikus_valtozok'] = True

            # 2. Norm√°l eloszl√°s ellen≈ërz√©se (Shapiro-Wilk teszt)
            _, p_x = stats.shapiro(df[oszlop].dropna())
            eredmenyek['normal_eloszlas_x'] = p_x > 0.05  # Ha p > 0.05, akkor norm√°l eloszl√°s√∫

            # 3. Folytonos v√°ltoz√≥k ellen≈ërz√©se

            # 3.1 Egyedi √©rt√©kek sz√°m√°nak vizsg√°lata
            egyedi_ertekek_x = df[oszlop].nunique()
            eredmenyek['folytonos_valtozo_x_ertekszam'] = egyedi_ertekek_x > folytonos_kuszob

            # 3.2 √ârt√©kek k√∂z√∂tti k√ºl√∂nbs√©gek vizsg√°lata
            kulonbsegek_x = np.diff(np.sort(df[oszlop].dropna().unique()))
            min_kulonbseg_x = np.min(kulonbsegek_x) if len(kulonbsegek_x) > 0 else np.inf
            eredmenyek['folytonos_valtozo_x_kulonbseg'] = min_kulonbseg_x < min_kulonbseg_kuszob

            # Kombin√°lt krit√©rium alapj√°n folytonoss√°g ellen≈ërz√©se
            eredmenyek['folytonos_x'] = eredmenyek['folytonos_valtozo_x_ertekszam'] and eredmenyek['folytonos_valtozo_x_kulonbseg']

    except Exception as e:
        # Hibakezel√©s: Ha valami hiba t√∂rt√©nik, r√∂gz√≠tj√ºk az √ºzenetet
        eredmenyek['hiba'] = str(e)

    return eredmenyek

def colstat(df):
    """
    A DataFrame √∂sszes oszlop√°n v√©gigiter√°l, megvizsg√°lja ≈ëket, √©s egy jelent√©s form√°j√°ban ki√≠rja az eredm√©nyeket.
    
    Param√©ter:
    df : pd.DataFrame
        Az elemzend≈ë adatkeret.
    
    Kimenet:
    pd.DataFrame : A jelent√©s, amely tartalmazza minden oszlop vizsg√°lat√°nak eredm√©nyeit.
    """
    print("a Dataframe sorainak sz√°ma: ", len(df))
    jelent√©s = []
    
    for oszlop in df.columns:
        eredmeny = egy_oszlop_vizsgalata(df, oszlop)
        sor = {
            'Column': oszlop,
            'Non-Null Count': df[oszlop].count(),
            'NaN Count': df[oszlop].isna().sum(),
            'Zero Count': (df[oszlop] == 0).sum().sum(),
            'Dtype': df[oszlop].dtype,
        }
        sor.update(eredmeny)
        jelent√©s.append(sor)
    
    jelent√©s_df = pd.DataFrame(jelent√©s)
    return jelent√©s_df

# P√©ldafelhaszn√°l√°s:
# df = pd.read_csv("adatok.csv")
# jelent√©s = colstat(df)
# print(jelent√©s)
# di(jelent√©s) ez strukt√∫r√°ltabb

###########################################################################################################################

# 240821 sz√≠nezett_korrel√°cios_m√°trix
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

def korrelacios_matrix(df):
    """
    L√©trehoz egy korrel√°ci√≥s m√°trixot a DataFrame oszlopai k√∂z√∂tt.
    
    Param√©ter:
    df : pd.DataFrame
        A bemeneti adatkeret.
    
    Visszat√©r√©si √©rt√©k:
    pd.DataFrame : A korrel√°ci√≥s m√°trix.
    """
    # V√©letlen oszlop gener√°l√°sa
    df['veletlen_oszlop'] = np.random.randn(len(df))
    
    # Korrel√°ci√≥s m√°trix sz√°m√≠t√°sa
    corr_matrix = df.corr()
    
    return corr_matrix

def szinezett_korrelacios_matrix(df):
    """
    Megjelen√≠ti a korrel√°ci√≥s m√°trixot sz√≠nezett h≈ët√©rk√©pk√©nt sz√©lesebb cell√°kkal √©s 5 tizedesjeggyel.
    
    Param√©ter:
    df : pd.DataFrame
        A bemeneti adatkeret.
    """
    # Korrel√°ci√≥s m√°trix l√©trehoz√°sa
    corr_matrix = korrelacios_matrix(df)
    
    # H≈ët√©rk√©p megjelen√≠t√©se sz√©lesebb cell√°kkal √©s 5 tizedesjeggyel
    plt.figure(figsize=(21, 8))  # N√∂velj√ºk a cell√°k sz√©less√©g√©t a figsize param√©terrel
    sns.heatmap(
        corr_matrix, 
        annot=True, 
        cmap='coolwarm', 
        vmin=-1, 
        vmax=1, 
        center=0, 
        fmt=".5f",  # Form√°zzuk az annot√°ci√≥kat 5 tizedesjegyre
        annot_kws={"size": 10}  # Be√°ll√≠thatjuk a bet≈±m√©retet is, ha sz√ºks√©ges
    )
    plt.title('Korrel√°ci√≥s m√°trix h≈ët√©rk√©pe')
    plt.show()

# P√©ldafelhaszn√°l√°s:
# df = pd.read_csv("adatok.csv")
# szinezett_korrelacios_matrix(df)

#############################################################################################################################

######### 2024.10.14 09:15:00 ################################## ADATDOKI ######
# A teljes k√©perny≈ë sz√©less√©g≈± k√≥dmegjelen√≠t√©st biztos√≠t Jupyter NbClassic-ban.
# Jupyter NbClassic-ban m≈±k√∂dik csak (localhost:8888/nbclassic/notebooks/)
#########1#########2#########3#########4#########5#########6#########7#########8

# Import√°ljuk a sz√ºks√©ges modulokat az aj√°nlott IPython.display-b≈ël
from IPython.display import display, HTML

# Teljes k√©perny≈ës sz√©less√©get biztos√≠t a Jupyter Notebookban
# display(HTML("<style>.container { width:100% !important; }</style>"))
# print('display(HTML("<style>.container { width:100% !important; }</style>"))')
###############################################################################################################################################################
